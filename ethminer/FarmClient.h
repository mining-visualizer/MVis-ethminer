/**
* This file is generated by jsonrpcstub, DO NOT CHANGE IT MANUALLY!
*/

#ifndef JSONRPC_CPP_STUB_FARMCLIENT_H_
#define JSONRPC_CPP_STUB_FARMCLIENT_H_

#include <jsonrpccpp/client.h>
#include <ethminer/SignTx.h>
#include <libethash/sha3_cryptopp.h>
#include <iostream>
#include <fstream>
#include <sstream>
#include <boost/filesystem.hpp>

using namespace std;
using namespace dev;
using namespace dev::eth;



/** libkeccak-tiny
*
* A single-file implementation of SHA-3 and SHAKE.
*
* Implementor: David Leon Gil
* License: CC0, attribution kindly requested. Blame taken too,
* but not liability.
*/

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/******** The Keccak-f[1600] permutation ********/

/*** Constants. ***/
static const uint8_t rho[24] = \
{ 1, 3, 6, 10, 15, 21,
28, 36, 45, 55, 2, 14,
27, 41, 56, 8, 25, 43,
62, 18, 39, 61, 20, 44};
static const uint8_t pi[24] = \
{10, 7, 11, 17, 18, 3,
5, 16, 8, 21, 24, 4,
15, 23, 19, 13, 12, 2,
20, 14, 22, 9, 6, 1};
static const uint64_t RC[24] = \
{1ULL, 0x8082ULL, 0x800000000000808aULL, 0x8000000080008000ULL,
0x808bULL, 0x80000001ULL, 0x8000000080008081ULL, 0x8000000000008009ULL,
0x8aULL, 0x88ULL, 0x80008009ULL, 0x8000000aULL,
0x8000808bULL, 0x800000000000008bULL, 0x8000000000008089ULL, 0x8000000000008003ULL,
0x8000000000008002ULL, 0x8000000000000080ULL, 0x800aULL, 0x800000008000000aULL,
0x8000000080008081ULL, 0x8000000000008080ULL, 0x80000001ULL, 0x8000000080008008ULL};

/*** Helper macros to unroll the permutation. ***/
#define rol(x, s) (((x) << s) | ((x) >> (64 - s)))
#define REPEAT6(e) e e e e e e
#define REPEAT24(e) REPEAT6(e e e e)
#define REPEAT5(e) e e e e e
#define FOR5(v, s, e)							\
	v = 0;										\
	REPEAT5(e; v += s;)

/*** Keccak-f[1600] ***/
static inline void keccakf(void* state) {
	uint64_t* a = (uint64_t*) state;
	uint64_t b[5] = {0};
	uint64_t t = 0;
	uint8_t x, y;

	for (int i = 0; i < 24; i++) {
		// Theta
		FOR5(x, 1,
			 b[x] = 0;
		FOR5(y, 5,
			 b[x] ^= a[x + y]; ))
			FOR5(x, 1,
				 FOR5(y, 5,
					  a[y + x] ^= b[(x + 4) % 5] ^ rol(b[(x + 1) % 5], 1); ))
			// Rho and pi
			t = a[1];
		x = 0;
		REPEAT24(b[0] = a[pi[x]];
		a[pi[x]] = rol(t, rho[x]);
		t = b[0];
		x++; )
			// Chi
			FOR5(y,
				 5,
				 FOR5(x, 1,
					  b[x] = a[y + x];)
				 FOR5(x, 1,
					  a[y + x] = b[x] ^ ((~b[(x + 1) % 5]) & b[(x + 2) % 5]); ))
			// Iota
			a[0] ^= RC[i];
	}
}

/******** The FIPS202-defined functions. ********/

/*** Some helper macros. ***/

#define _(S) do { S } while (0)
#define FOR(i, ST, L, S)							\
	_(for (size_t i = 0; i < L; i += ST) { S; })
#define mkapply_ds(NAME, S)						\
	static inline void NAME(uint8_t* dst,			\
		const uint8_t* src,						\
		size_t len) {								\
		FOR(i, 1, len, S);							\
	}
#define mkapply_sd(NAME, S)						\
	static inline void NAME(const uint8_t* src,	\
		uint8_t* dst,								\
		size_t len) {								\
		FOR(i, 1, len, S);							\
	}

mkapply_ds(xorin, dst[i] ^= src[i])  // xorin
mkapply_sd(setout, dst[i] = src[i])  // setout

#define P keccakf
#define Plen 200

// Fold P*F over the full blocks of an input.
#define foldP(I, L, F)								\
	while (L >= rate) {							\
		F(a, I, rate);								\
		P(a);										\
		I += rate;									\
		L -= rate;									\
	}

/** The sponge-based hash construction. **/
int hashtest(uint8_t* out, size_t outlen,
		const uint8_t* in, size_t inlen,
		size_t rate, uint8_t delim) 
{
	if ((out == NULL) || ((in == NULL) && inlen != 0) || (rate >= Plen)) {
		return -1;
	}
	uint8_t a[Plen] = {0};
	// Absorb input.
	//foldP(in, inlen, xorin);
	// Xor in the DS and pad frame.
	a[inlen] ^= delim;
	a[rate - 1] ^= 0x80;
	// Xor in the last block.
	xorin(a, in, inlen);
	// Apply P
	P(a);
	// Squeeze output.
	foldP(out, outlen, setout);
	setout(a, out, outlen);
	memset(a, 0, 200);
	return 0;
}

int sha3_256(uint8_t* out, size_t outlen, const uint8_t* in, size_t inlen) {								
	if (outlen > (256/8)) {										
		return -1;                                                  
	}																
	return hashtest(out, outlen, in, inlen, 200 - (256 / 4), 0x01);
}





class FarmClient : public jsonrpc::Client
{
public:

	FarmClient(jsonrpc::IClientConnector &conn, jsonrpc::clientVersion_t type = jsonrpc::JSONRPC_CLIENT_V2) : jsonrpc::Client(conn, type) 
	{
		m_minerAcct = ProgOpt::Get("0xBitcoin", "MinerAcct");
		m_tokenContract = ProgOpt::Get("0xBitcoin", "TokenContract");
		m_acctPK = ProgOpt::Get("0xBitcoin", "AcctPK");
	}

	int getNextNonce() {
		// get transaction count for nonce
		Json::Value p;
		p.append(m_minerAcct);
		p.append("latest");
		Json::Value result = this->CallMethod("eth_getTransactionCount", p);
		std::istringstream converter(result.asString());
		int i;
		converter >> std::hex >> i;
		return i;
	}

	uint64_t tokenBalance() {
		Json::Value p;
		p["from"] = m_minerAcct;			// ETH address (Jaxx HD)
		p["to"] = m_tokenContract;			// 0xbitcoin contract address

		h256 bMethod = sha3("balanceOf(address)");
		std::string sMethod = toHex(bMethod, dev::HexPrefix::Add);
		sMethod = sMethod.substr(0, 10);

		// address
		stringstream ss;
		ss << std::setw(64) << std::setfill('0') << m_minerAcct.substr(2);
		std::string s2(ss.str());
		sMethod = sMethod + s2;
		p["data"] = sMethod;

		Json::Value data;
		data.append(p);
		data.append("latest");

		Json::Value result = this->CallMethod("eth_call", data);
		u256 balance = u256(result.asString()) / 100000000;
		if (result.isString()) {
			return static_cast<uint64_t>(balance);
		} else
			throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
	}

	void testkeccak() {
		h256 nonce = h256::random();
		bytes challenge(32);
		memcpy(challenge.data(), nonce.data(), 32);
		nonce = h256::random();

		bytes mix(84);
		memcpy(&mix[0], challenge.data(), 32);
		h160 sender(m_minerAcct);
		memcpy(&mix[32], sender.data(), 20);
		memcpy(&mix[52], nonce.data(), 32);
		bytes hash(32);
		SHA3_256((const ethash_h256_t*) hash.data(), (const uint8_t*) mix.data(), 84);
		LogS << "0x" << toHex(hash);

		sha3_256(hash.data(), 32, mix.data(), 84);
		LogS << "0x" << toHex(hash);
	}


	void testTransaction() {

		// get transaction count for nonce
		Json::Value p;
		p.append(m_minerAcct);
		p.append("latest");
		Json::Value result = this->CallMethod("eth_getTransactionCount", p);
		std::istringstream converter(result.asString());
		int nonce;
		converter >> std::hex >> nonce;

		// prepare transaction
		Transaction t;
		t.nonce = nonce;
		t.receiveAddress = toAddress("0x29224Be72851D7Bad619f64c2E51E8Ca5Ba1094b");
		t.gas = u256(21000);
		t.gasPrice = u256(10000000000);
		t.data = fromHex("");
		t.value = 4000000000;
		Secret pk = Secret("d1ced27471f165c1d42b2e225c416125fa998900a2865b2168686c34e5520e24");
		t.sign(pk);
		stringstream ss;
		ss << "0x" << toHex(t.rlp());

		// submit to the node
		p.clear();
		p.append(ss.str());
		result = this->CallMethod("eth_sendRawTransaction", p);
		cout << "tx send result : " << result.asString() << endl;

	}

	Json::Value eth_getWork() throw (jsonrpc::JsonRpcException) {
		Json::Value p;
		p = Json::nullValue;
		Json::Value result = this->CallMethod("eth_getWork", p);
		if (result.isArray())
			return result;
		else
			throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
	}

	void eth_getWork_token(bytes& _challenge, h256& _target) throw (jsonrpc::JsonRpcException) {
		// challenge
		Json::Value p;
		p["from"] = m_minerAcct;			// ETH address (Jaxx HD)
		p["to"] = m_tokenContract;			// 0xbitcoin contract address

		h256 bMethod = sha3("getChallengeNumber()");
		std::string sMethod = toHex(bMethod, dev::HexPrefix::Add);
		p["data"] = sMethod.substr(0, 10);

		Json::Value data;
		data.append(p);
		data.append("latest");

		Json::Value result = this->CallMethod("eth_call", data);
		if (result.isString()) {
			_challenge = fromHex(result.asString());
		} else
			throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
		LogF << "Trace: eth_getWork_token, Challenge : " << toHex(_challenge);

		// target
		bMethod = sha3("getMiningTarget()");
		sMethod = toHex(bMethod, dev::HexPrefix::Add);
		p["data"] = sMethod.substr(0, 10);

		data.clear();
		data.append(p);
		data.append("latest");

		result = this->CallMethod("eth_call", data);
		if (result.isString()) {
			_target = h256(result.asString());
		} else
			throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());

	}

	void testHash(h256 nonce, bytes challenge)  throw (jsonrpc::JsonRpcException) {
		std::vector<byte> mix(84);
		std::ostringstream ss;
		Json::Value p;
		p["from"] = m_minerAcct;		// ETH address (Jaxx HD)
		p["to"] = m_tokenContract;		// 0xbitcoin contract address

		// function signature
		h256 bMethod = sha3("getMintDigest(uint256,bytes32)");
		std::string sMethod = toHex(bMethod, dev::HexPrefix::Add);
		sMethod = sMethod.substr(0, 10);

		// nonce
		ss << std::setw(64) << std::setfill('0') << nonce.hex();
		std::string s2(ss.str());
		sMethod = sMethod + s2;
		memcpy(&mix[52], nonce.data(), 32);

		// challenge_number
		ss = std::ostringstream();
		ss << std::left << std::setw(64) << std::setfill('0') << toHex(challenge);
		s2 = std::string(ss.str());
		sMethod = sMethod + s2;

		p["data"] = sMethod;

		Json::Value data;
		data.append(p);
		data.append("latest");

		Json::Value result = this->CallMethod("eth_call", data);
		if (result.isString()) {
			LogS << "test hash";
			LogS << result.asString();

			h160 sender(m_tokenContract);
			memcpy(&mix[0], challenge.data(), 32);
			memcpy(&mix[32], sender.data(), 20);
			bytes hash(32);
			SHA3_256((const ethash_h256_t*) hash.data(), (const uint8_t*) mix.data(), 84);
			LogS << "0x" << toHex(hash);
			LogS << "end test";

		} else
			throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
	}

	bool eth_submitWork(const std::string& param1, const std::string& param2, const std::string& param3) throw (jsonrpc::JsonRpcException) {
		Json::Value p;
		p.append(param1);
		p.append(param2);
		p.append(param3);
		Json::Value result = this->CallMethod("eth_submitWork", p);
		if (result.isBool())
			return result.asBool();
		else
			throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
	}

	bool eth_submitWorkToken(h256 _nonce, bytes _hash, bytes _challenge) throw (jsonrpc::JsonRpcException) {

		try {
			// check if the other miner already submitted a solution for this challenge
			boost::filesystem::path m_challengeFilename = boost::filesystem::path(ProgOpt::Get("0xBitcoin", "ChallengeFolder")) / "challenge.txt";
			ifstream ifs;
			if (boost::filesystem::exists(m_challengeFilename)) {
				string s;
				ifs.open(m_challengeFilename.generic_string(), fstream::in);
				getlineEx(ifs, s);
				if (s == toHex(_challenge)) {
					LogS << "The other miner already got this one : " << toHex(_challenge).substr(0, 8);
					return false;
				}
			}
			ifs.close();
			// write this challenge value to our synchronization file.
			std::ofstream ofs(m_challengeFilename.generic_string(), std::ofstream::out);
			ofs << toHex(_challenge);
			ofs.close();
		}
		catch (const std::exception& e) {
			LogB << "Exception: eth_submitWorkToken - " << e.what();
		}


		// prepare transaction
		Transaction t;
		if (m_lastSolution.elapsedSeconds() > 5 * 60 || m_txNonce == -1) {
			m_txNonce = getNextNonce();
		} else {
			m_txNonce++;
		}
		m_lastSolution.restart();
		t.nonce = m_txNonce;
		t.receiveAddress = toAddress(m_tokenContract);
		//t.gas = u256(119840);
		t.gas = u256(219840);
		ProgOpt::Load("");
		t.gasPrice = u256(ProgOpt::Get("0xBitcoin", "GasPrice")) * 1000000000;	// convert gwei to wei

		// compute data parameter : first 4 bytes is hash of function signature
		h256 bMethod = sha3("mint(uint256,bytes32)");
		std::string sMethod = toHex(bMethod, dev::HexPrefix::Add);
		sMethod = sMethod.substr(0, 10);
		// put the nonce in
		stringstream ss;
		ss << std::setw(64) << std::setfill('0') << _nonce.hex();
		std::string s2(ss.str());
		sMethod = sMethod + s2;
		// and the hash
		ss = std::stringstream();
		ss << std::left << std::setw(64) << std::setfill('0') << toHex(_hash);
		s2 = std::string(ss.str());
		sMethod = sMethod + s2;
		t.data = fromHex(sMethod);
		t.value = 0;

		Secret pk = Secret(m_acctPK);
		t.sign(pk);
		ss = std::stringstream();
		ss << "0x" << toHex(t.rlp());

		// submit to the node 
		Json::Value p;
		p.append(ss.str());
		//LogS << "Raw transaction to send : " << ss.str();
		Json::Value result = this->CallMethod("eth_sendRawTransaction", p);
		LogS << "Tx hash : " << result.asString();
		return true;
	}

	void eth_checkWorkToken(h256 _nonce, bytes _challenge, bytes _hash, h256 _target) {
		// this calls the mint(nonce, challenge) function using eth_call so it can check the return result
		std::ostringstream ss;
		Json::Value p;
		p["from"] = m_minerAcct;		// ETH address (Jaxx HD)
		p["to"] = m_tokenContract;		// 0xbitcoin contract address

		// function signature
		h256 bMethod = sha3("mint(uint256,bytes32)");
		//h256 bMethod = sha3("checkMintSolution(uint256,bytes32,bytes32,uint256)");
		std::string sMethod = toHex(bMethod, dev::HexPrefix::Add);
		sMethod = sMethod.substr(0, 10); 

		// nonce
		ss << std::setw(64) << std::setfill('0') << _nonce.hex();
		std::string s2(ss.str());
		sMethod = sMethod + s2;

		// hash
		ss = std::ostringstream();
		ss << std::left << std::setw(64) << std::setfill('0') << toHex(_hash);
		s2 = std::string(ss.str());
		sMethod = sMethod + s2;

		// challenge_number
		//ss = std::ostringstream();
		//ss << std::left << std::setw(64) << std::setfill('0') << toHex(_challenge);
		//s2 = std::string(ss.str());
		//sMethod = sMethod + s2;

		// target  (this is for checkMintSolution only)
		//ss = std::ostringstream();
		//ss << std::setw(64) << std::setfill('0') << _target.hex();
		//s2 = std::string(ss.str());
		//sMethod = sMethod + s2;


		p["data"] = sMethod;

		Json::Value data;
		data.append(p);
		data.append("latest");

		Json::Value result = this->CallMethod("eth_call", data);
		if (result.isString()) {
			LogS << "mint() returns : " << result.asString();
		} else
			throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
	}

	bool eth_submitHashrate(const std::string& param1, const std::string& param2) throw (jsonrpc::JsonRpcException) {
		Json::Value p;
		p.append(param1);
		p.append(param2);
		Json::Value result = this->CallMethod("eth_submitHashrate", p);
		if (result.isBool())
			return result.asBool();
		else
			throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
	}

	Json::Value eth_awaitNewWork() throw (jsonrpc::JsonRpcException) {
		Json::Value p;
		p = Json::nullValue;
		Json::Value result = this->CallMethod("eth_awaitNewWork", p);
		if (result.isArray())
			return result;
		else
			throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
	}

	bool eth_progress() throw (jsonrpc::JsonRpcException) {
		Json::Value p;
		p = Json::nullValue;
		Json::Value result = this->CallMethod("eth_progress", p);
		if (result.isBool())
			return result.asBool();
		else
			throw jsonrpc::JsonRpcException(jsonrpc::Errors::ERROR_CLIENT_INVALID_RESPONSE, result.toStyledString());
	}

private:
	string m_minerAcct;
	string m_acctPK;
	string m_tokenContract;
	int m_txNonce = -1;
	Timer m_lastSolution;


};

#endif //JSONRPC_CPP_STUB_FARMCLIENT_H_
